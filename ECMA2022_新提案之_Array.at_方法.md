---
title: "ECMA2022 新提案之 Array.at 方法"
description: "ECMA 新语法，数组 API"
author: protogenesis
---

##### 所有的”索引类“（Array，String，TypedArray）都添加 .at() 方法

目前已经在 ECMA 2022 中实施，大部分浏览器都已经支持。

动机：

长期以来，编程人员希望能有一种方法可以"负向访问"某一个 JS 数组的元素，就像在 Python 中一样。

例如：通过 ```arr[-1]``` 这种方式访问数组的最后一个成员，而不是 ```arr[arr.leng-1]```。

不幸的是，JS 的语法设计使得这种可能性为 0，因为 ```[]``` 这种语法不仅仅是 "索引类" （例如 Array，String）有，对象也可以使用这种语法。通过 ```arr[1]``` 这种方式访问某个成员，其实就是访问对象上的某个属性，属性的 key 为 "1"，但这种方式仅仅在对象上面才有。

虽然我们可以在代码中写 ```arr[-1]``` 而不会报错，但是它的返回值为 ```arr``` 这个对象上 key 为 ”-1“ 的属性，而不是返回一个从后往前按顺序查找的索引对应的元素。

当前存在的方法：

目前，要从后往前访问一个对象上的某一个索引，通用的方式是 ```arr[arr.length - n]```，n 是从后往前的第几项（从 1 开始），这种方式需要书写两次 arr，还需要访问 ```.length``` 属性，并且对于匿名的值也不友好：例如你无法用这种方法获取一个函数返回值的最后一项，除非你用一个临时变量将它存储起来。

还有一种方式是通过 ```arr.slice(-n)[0]``` 来访问，这样不需要重复书写两次变量，对于匿名值来说也是可以访问的，但是这种方式有一定的性能问题。这种方式拼起来有一点点怪异，尤其是后面的 ```[0]```（因为 ```.slice()``` 返回一个 array）。同样，一个临时的包含着从 n 开始的 arr 临时变量被创建了。

不管怎么样，通过 ```.slice()``` 方法（或者类似的 ```.splice()```）方法确实存在通过负值索引访问的情况。

---

##### 示例：

```javascript
const arr = ['a', 'b', 'c']

console.log(arr.at(-1)) // c

const str = 'abcd'

console.log(str.at(-2)) // c
```



原文：

> https://github.com/tc39/proposal-relative-indexing-method#dom-justifications